---
title: placeholder
date: 2025-06-02 (estimated)
---

Hey there, I'm Dylan, welcome to my blog! I'm a doctoral student at San Diego State University; I'll be making regular posts throughout the summer as I work on my 2025 Google Summer of Code project, the goal of which is to create a generalized routing engine for the `spopt` package in `pysal`. I'll post mostly about the project itself: tracking my progress, describing my tooling, and hopefully producing useful information for other amatuer developers to start contributing to open-source software. In this first post, I briefly describe the project and my coding environment.

When trying to describe this project in conversation, I've basically said that it's a way to specify routing distances (including the route itself) for optimization problems using user-provided data. A user might have a problem that involves deliveries of a product to a depot or customer that needs to utilize a road network. These kinds of problems are very applicable for logistics, generally speaking. An example of this could be the [guiness delivery example](https://gist.github.com/ljwolf/e5927ab8c859ed477f496329c1ce19fc#file-guinness-py) produced by Dr. Levi Wolf, a mentor on this project. Important parameters for these problems include the amount of product that needs to be delivered, the number of trucks available, the destinations and the volume of product desired, and delivery windows (time requirements). There are lots of ways the vehicles can traverse the city, but some routes will be faster than others, and one will likley be *the best*. These kinds of problems are called vehicle routing problems (VRP). Extant code for this project includes a solver to handle these problems, but my work over the summer will produce an engine which grabs the appropriate road network data.

The first lift for me was getting onboarded to the project, which means invocating a research environment. 

As a student researcher at the [Center for Open Geographic Science](cogs.sdsu.edu), I'm fortunate to have access to a *poweful* research server with more processing power than my laptop, but it can be awkward to edit code or write prose with compared to my well-honed [emacs](https://www.gnu.org/software/emacs/emacs-paper.html) configuration. My strategy to get the best of both worlds means that from my local machine, I use SSH to tunnel into the remote research server, where I instantiate a jupyter lab and run my code. I edit code and take notes side by side on emacs, and `git push` my changes to my remote fork and branch of the project on github. Then, in my jupyter instance, I `git pull` those changes in. 

This seems like it could be clunky because I cannot directly edit the code base and call a function, but it has its advantages. Firstly, it gives me the full range of motion enabled by emacs. Long have I slaved over my keybinding scheme and *elisp* syntax to create an environment that allows me to swiftly perform a desired function and move between production modes. Crucially, this includes git and github through an package called *magit*, which makes commiting and pushing convinient and fluid, at least compared to the command line. The second advantage this gives me is that it forces me to push my changes frequently, meaning a richer commit history. Lastly, because this project aims to use optimization and can involve dense travel network data, being able to leverage the more powerful research server is highly desirable.

The downside of tunnel coding is that sometimes I need to adjust the PATH to get the server to recognize where I'm pointing. I'm not trained in computer science, all of my know-how is DIY, though being raised alongside computers in the 90s has meant that I do have pretty good intuition about how to solve problems. However, porting and PATHing has always been difficult for me.

Using this setup, I created a new environment using *mamba* and cloned the draft [pull request](https://github.com/pysal/spopt/pull/465) for the project and ensured I had the new module, now it's time to test the functionality.

I thought 'let's just grab this thing and see how far I can get just running it as is' but of course, only 3 lines in I hit a traceback because the interpreter is trying to set the index on a network identifier, which of course I don't have. The solver is supposed to recognize that there is no network provided, but I've just grabbed the code as is in the guiness example, which includes defined parameters for the network. Since I've spent most of the day getting set up here, I will take importing the pull request as a successful work day. Next time, I will describe how the solver can work *without* a road network, as well as describe how we're approaching a generalized implementation of a routing engine. 